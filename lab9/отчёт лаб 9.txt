Лабораторная работа 9, Наумкина Александра Р3122

Тема работы: Реализация CRUD-операций и освоение принципов MVC на примере приложения для отслеживания курсов валют.
Цель работы:Реализовать CRUD (Create, Read, Update, Delete) для сущностей бизнес-логики приложения.
Освоить работу с SQLite в памяти (:memory:) через модуль sqlite3.
Понять принципы первичных и внешних ключей и их роль в связях между таблицами.
Выделить контроллеры для работы с БД и для рендеринга страниц в отдельные модули.
Использовать архитектуру MVC и соблюдать разделение ответственности.
Отображать пользователям таблицу с валютами, на которые они подписаны.
Реализовать полноценный роутер, который обрабатывает GET-запросы и выполняет сохранение/обновление данных и рендеринг страниц.
Научиться тестировать функционал на примере сущностей currency и user с использованием unittest.mock.

1. Описание моделей, их свойств и связей

В приложении используются три основные сущности, определенные в модуле `models.py`.

1.1. Модели данных
User: Представляет пользователя системы. Имеет свойства:

id (Первичный ключ).

name.

Currency: Представляет валюту и ее курс. Имеет свойства:

id (Первичный ключ).

num_code (Цифровой код валюты).

char_code (Символьный код, например, 'USD').

name (Полное название).

value (Курс к рублю).

nominal (Номинал).

UserCurrency: Служит для реализации связи "многие-ко-многим" между пользователями и валютами (подписка). Имеет свойства:

id (Первичный ключ).

user_id (Внешний ключ).

currency_id (Внешний ключ).

1.2. Описание связей (Ключевые принципы БД)

Связь между User и Currency реализована через промежуточную сущность UserCurrency.

Первичные ключи (Primary Keys, PK): Столбцы id во всех трех таблицах (users, currencies, user_currencies) используются для уникальной идентификации записей.

Внешние ключи (Foreign Keys, FK):

Поле UserCurrency.user_id является Внешним ключом и ссылается на User.id.

Поле UserCurrency.currency_id является Внешним ключом и ссылается на Currency.id.

Для обеспечения целостности данных при удалении используется принцип ON DELETE CASCADE. Если пользователь или валюта удаляется, все связанные с ними записи в таблице user_currencies также автоматически удаляются.

2. Структура проекта с назначением файлов

Проект разработан с использованием архитектурного шаблона **Model-View-Controller (MVC)**, что обеспечивает четкое разделение обязанностей.

 main.py: Запускает HTTP-сервер, содержит роутинг (SimpleHTTPRequestHandler) для обработки GET и POST запросов, а также инициализирует базу данных и тестовые данные.

models.py: Определяет классы-сущности, представляющие данные (Model).

templates/: Содержит шаблоны HTML, использующие Jinja2 для динамического отображения информации (View).

controllers/databasecontroller.py: Отвечает за низкоуровневый доступ к данным, управляет подключением к SQLite в памяти и выполняет базовые SQL-запросы.

controllers/usercontroller.py: Содержит бизнес-логику для CRUD-операций сущности User.

controllers/currencycontroller.py: Содержит бизнес-логику для CRUD-операций сущности Currency.

controllers/usercurrencycontroller.py: Управляет созданием и получением связей (подписок) между пользователями и валютами.

utils/currencies_cbapi.py: Имитирует внешний API для получения обновленных курсов валют.

3. Реализация CRUD с примерами SQL-запросов

Все операции доступа к данным инкапсулированы в контроллерах, которые используют `DatabaseController` для выполнения SQL-запросов к **SQLite в памяти**.

3.1. Create (Создание)

Операция: Создание новой валюты (`CurrencyController.create_currency`).
Пример SQL-запроса:`INSERT INTO currencies (num_code, char_code, name, value, nominal) VALUES (?, ?, ?, ?, ?)`

3.2. Read (Чтение/Просмотр)

Операция: Получение списка всех валют, на которые подписан конкретный пользователь (`UserCurrencyController.get_user_currencies_detailed`).
Пример SQL-запроса (использует JOIN):
`SELECT c.char_code, c.name, c.value, c.nominal FROM user_currencies uc JOIN currencies c ON uc.currency_id = c.id WHERE uc.user_id = ?`

3.3. Update (Обновление)

Операция: Обновление имени пользователя (`UserController.update_user`).
Пример SQL-запроса: `UPDATE users SET name = ? WHERE id = ?`

3.4. Delete (Удаление)
Операция:Удаление валюты (`CurrencyController.delete_currency`).
Пример SQL-запроса: `DELETE FROM currencies WHERE id = ?`
Связанная операция: Удаление подписок в `user_currencies` происходит автоматически благодаря внешнему ключу с **ON DELETE CASCADE**.

4. Примеры тестов с unittest.mock

Для проверки корректности контроллеров в условиях изоляции (без реальной базы данных) использовались тестовые заглушки (`unittest.mock`).

Пример 1: Тестирование создания валюты (`CurrencyController.create_currency`)

def test_create_currency(self):
    self.mock_db.execute.return_value = 5 # Имитируем ID новой строки
    
    currency_id = self.controller.create_currency('980', 'UAH', 'Украинская гривна', 2.30, 1)
    
    self.assertEqual(currency_id, 5)
    
    # Проверяем, что execute вызван с правильными параметрами:
    self.mock_db.execute.assert_called_once_with(
        unittest.mock.ANY, 
        ('980', 'UAH', 'Украинская гривна', 2.30, 1),
        commit=True
    )


Пример 2: Тестирование обновления пользователя (`UserController.update_user`)


def test_update_user(self):
    self.mock_db.cursor.rowcount = 1 # Имитируем, что затронута 1 строка
    
    success = self.controller.update_user(1, name='Иван С.')
    
    self.assertTrue(success)
    
    # Проверяем корректность сгенерированного SQL:
    self.mock_db.execute.assert_called_once_with(
        'UPDATE users SET name = ? WHERE id = ?',
        ('Иван С.', 1),
        commit=True
    )

**Результаты выполнения тестов:** Все тесты были успешно пройдены, подтверждая, что контроллеры правильно формируют и передают запросы слою доступа к данным.


$ python test_controllers.py
..
----------------------------------------------------------------------
Ran 4 tests in 0.00x s

OK


5. Выводы о применении MVC, работе с SQLite, обработке маршрутов и рендеринге шаблонов

Применение MVC:Успешное внедрение архитектуры MVC обеспечило четкое разделение ответственности между моделями, контроллерами и представлениями. Это значительно упростило тестирование (изоляция контроллеров через mock-объекты) и поддержку кода.

Работа с SQLite в памяти (`:memory:`): Использование `sqlite3.connect(':memory:')` позволило создать изолированную, временную базу данных для выполнения лабораторной работы. Это продемонстрировало эффективное применение SQLite для быстрого прототипирования и тестирования без необходимости управления файлами базы данных.

Обработка маршрутов (Роутер):Класс `SimpleHTTPRequestHandler` реализован как полноценный роутер, способный обрабатывать различные типы HTTP-запросов (GET для чтения/удаления и POST для создания/обновления). Использование `urllib.parse` для работы с параметрами URL и данными формы позволило создать интерактивное веб-приложение.

Рендеринг шаблонов (Jinja2):Jinja2 эффективно использовалась для создания динамического пользовательского интерфейса. Это позволило контроллерам сосредоточиться на бизнес-логике, передавая сырые данные, а шаблонам — на их форматированном отображении (например, курсов валют с точностью до 4 знаков после запятой) и организации форм для CRUD-операций.